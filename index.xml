<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming, thoughts and paradigms</title>
    <link>https://syscll.org/</link>
    <description>Recent content on Programming, thoughts and paradigms</description>
    <language>en-gb</language>
    <lastBuildDate>Tue, 22 Oct 2019 23:00:00 +0100</lastBuildDate>
    
	<atom:link href="https://syscll.org/index.xml" rel="self" type="application/rss+xml" />

    <item>
      <title>Understanding Mutexes</title>
	  <link>https://syscll.org/understanding-mutexes/</link>
      <pubDate>Tue, 22 Oct 2019 23:00:00 +0100</pubDate>
	  <guid>https://syscll.org/understanding-mutexes/</guid>
      <description>&lt;p&gt;Those of us familiar with concurrency and parallelism know just how useful a mutex can be when protecting access to resources. But how do they work?&lt;/p&gt; &lt;p&gt;Here is a basic example, in Go, of a struct with a &lt;code&gt;count&lt;/code&gt; field and a method that increments this field when called:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;package&&lt;br&gt;&lt;br&gt;main&lt;br&gt;&lt;br&gt;import "sync"&lt;br&gt;&lt;br&gt;type protected struct {&lt;br&gt;count int&lt;br&gt;mtx sync.Mutex&lt;br&gt;}&lt;br&gt;&lt;br&gt;func (p *protected) inc() {&lt;br&gt;p.mtx.Lock()&lt;br&gt;p.count++&lt;br&gt;p.mtx.Unlock()&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;As you can see, we lock the mutex, increment the counter, then unlock the mutex before returning. But at no point do we associate the mutex with a specific field. So how exactly does it protect access to &lt;code&gt;p.count&lt;/code&gt;?&lt;/p&gt; &lt;p&gt;While many other languages have similar implementations, for the purposes of this post I'm going to refer to a mutex in &lt;a href=&quot;https://golang.org/pkg/sync/#Mutex&quot;&gt;Go&lt;/a&gt;.&lt;/p&gt; &lt;h3&gt;Lock/Unlock&lt;/h3&gt; &lt;p&gt;Under the hood, when &lt;code&gt;Lock()&lt;/code&gt; is called, the mutex will attempt to perform an atomic compare-and-swap operation on an unexported &lt;code&gt;int32&lt;/code&gt; field. As the default "unlocked" value of this field is 0, if successful, this field will now equal 1 and we can consider the mutex to be locked. Similarly, &lt;code&gt;Unlock()&lt;/code&gt; attempts to set the field back to 0.&lt;/p&gt; &lt;p&gt;So what happens if we attempt to lock a mutex that is already locked? This depends on the current mode of the mutex, which is one of either normal or starvation.&lt;/p&gt; &lt;h3&gt;Normal&lt;/h3&gt; &lt;p&gt;In normal mode, calls to Lock/Unlock are queued in &lt;a href=&quot;https://en.wikipedia.org/wiki/FIFO_and_LIFO_accounting#FIFO&quot;&gt;FIFO&lt;/a&gt; order. Each call will continually attempt to operate the mutex until eventually failing if it has been trying for more than 1ms - at which point it enters starvation mode.&lt;/p&gt; &lt;p&gt;Each outstanding call will compete with other calls for ownership of the mutex. It is quite common for newer calls to succeed first as they are already running on the CPU.&lt;/p&gt; &lt;h3&gt;Starvation&lt;/h3&gt; &lt;p&gt;In starvation mode, ownership of the mutex is handed off to the caller waiting at the front of the queue. Newer callers don't try to acquire the mutex even if it appears to be unlocked and instead of continually attempting to operate the mutex, they will queue themselves at the end of the queue.&lt;/p&gt; &lt;p&gt;If a caller sees that it is last in the queue, or it has waited for less time than the 1ms timeout, the mutex is set back to normal mode.&lt;/p&gt; &lt;h3&gt;Considerations&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;Attempting to unlock an unlocked mutex will result in a panic.&lt;/li&gt; &lt;li&gt;It is possible to bypass a mutex if you have direct access to the resource memory, e.g., a pointer.&lt;/li&gt; &lt;li&gt;Don't hold a mutex while performing long running tasks, e.g., IO-based operations.&lt;/li&gt; &lt;li&gt;In some cases is can be more efficient to use a channel to protect access to shared resources.&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;Resources&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://golang.org/pkg/sync/&quot;&gt;Go Package: sync&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://golang.org/pkg/sync/atomic&quot;&gt;Go Package: sync/atomic&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Compare-and-swap&quot;&gt;Compare-and-Swap (CAS)&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Parallel tests in Go</title>
	  <link>https://syscll.org/parallel-tests-go/</link>
      <pubDate>Tue, 8 Oct 2019 17:00:00 +0100</pubDate>
	  <guid>https://syscll.org/parallel-tests-go/</guid>
      <description>A great feature of Go is the ability to run tests in parallel using the default testing package.</description>
    </item>

    <item>
      <title>KubeCon &amp; CloudNativeCon - North America '18</title>
	  <link>https://syscll.org/kubecon-18/</link>
      <pubDate>Sun, 30 Dec 2018 17:00:00 +0100</pubDate>
	  <guid>https://syscll.org/kubecon-18/</guid>
      <description>With a grand total of 8000 attendees, 150+ speakers, 250+ talks, 100+ sponsors and more swag than I've ever seen at a conference, this was an event not to be missed.</description>
    </item>

    <item>
      <title>Remote Cohesion</title>
	  <link>https://syscll.org/remote-cohesion/</link>
      <pubDate>Fri, 30 Nov 2018 17:00:00 +0100</pubDate>
	  <guid>https://syscll.org/remote-cohesion/</guid>
      <description>I've been working partially remote for the last 3 years and although at times it's been challenging, it's mostly been a success.</description>
    </item>

    <item>
      <title>Kubernetes: Migrating legacy services</title>
	  <link>https://syscll.org/k8s-migration/</link>
      <pubDate>Wed, 31 Oct 2018 17:00:00 +0100</pubDate>
	  <guid>https://syscll.org/k8s-migration/</guid>
      <description>Firstly, let me explain what I mean by a legacy service: code that has never run on a container orchestration platform. The chances are your services were designed to run independently, on a node with plenty of resources, without being constantly restarted.</description>
    </item>
    
    <item>
      <title>Kubernetes: Canary release</title>
	  <link>https://syscll.org/k8s-canary-release/</link>
      <pubDate>Fri, 11 May 2018 17:00:00 +0100</pubDate>
	  <guid>https://syscll.org/k8s-canary-release/</guid>
      <description>Kubernetes makes light work of giving us the ability to deploy a canary release.</description>
    </item>
    
    <item>
      <title>Kubernetes: Service ports</title>
	  <link>https://syscll.org/k8s-service-ports/</link>
      <pubDate>Thu, 05 Apr 2018 17:00:00 +0100</pubDate>
	  <guid>https://syscll.org/k8s-service-ports/</guid>
      <description>Recently, I've been creating a lot of both internal and internet-facing LoadBalancer Services as this is a great way to expose your cluster to traffic. When doing this on AWS, unless specified otherwise, Kubernetes will automatically create a Classic Load Balancer and attach the relevant instances.</description>
	</item>

    <item>
      <title>Manage channel operations using context</title>
	  <link>https://syscll.org/manage-channel-ops/</link>
      <pubDate>Fri, 05 May 2017 17:00:00 +0100</pubDate>
	  <guid>https://syscll.org/manage-channel-ops/</guid>
      <description>I was recently working on a small personal project when I came across a problem during some testing. I had written an application that starts a HTTP server, accepts requests, and serves content from an in-memory data store.</description>
    </item>
  </channel>
</rss>
