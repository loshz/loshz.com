<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Programming thoughts and paradigms: A collection of articles focused on systems programming, Linux networking and security.">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Manage channel operations using context</title>
	<link rel="stylesheet" href="/site.css" />
    <link rel="icon" type="image/png" href="/images/favicon.png" />
	<link rel="alternate" type="application/rss+xml" href="https://loshz.com/index.xml" title="Programming thoughts and paradigms" />
</head>
<body>
	<header>
		<ul>
			<li><h2><a href="/">Dan Bond</a></h2></li>
			<li><a href="https://github.com/loshz"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Pro 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></li>
			<li><a href="https://twitter.com/loshz"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a></li>
			<li><a href="/index.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM128 416c0 35.3-28.7 64-64 64s-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"/></svg></a></li>
		</ul>
	</header>
	
	<div class="content">
<h1>Manage channel operations using context</h1>
<p class="date">2017-05-05</p>
			<p>I was recently working on a small personal project when I came across a problem during some testing. I had written an application that starts a HTTP server, accepts requests, and serves content from an in-memory data store.</p>
			<p>The basic application logic is as follows:</p>
			<ol>
				<li>Start servers and listen for requests.</li>
				<li>Create a channel to handle data store read requests.</li>
				<li>Upon accepting a request, push a data store read request onto the channel.</li>
				<li>Send data from data store down returning data read request channel.</li>
				<li>Serve data to client.</li>
			</ol>
			<p>So, the problem I noticed was the ability for the request to be cancelled at any point for one of several reasons: request timeout; client cancellation; server error; etc. Any one of these <em>errors</em> can happen at any point throughout the request, more importantly, once the individual request has been pushed onto the data read request channel. This is a huge problem as there could be potential items in this channel that are no longer needed, and because unbuffered channels in Go are blocking, the sender blocks until the receiver has received a value.</p>
			<p>After a bit of trial and error, research, and <a href="http://stackoverflow.com/questions/43683180/managing-channels-using-a-http-request-context">unanswered questions</a>, I decided to use the request context to try and solve this problem. The context package was introduced into the standard library in Go 1.7, but prior to this it was part of the <a href="http://golang.org/x/net/context">golang.org/x/net/context</a> library. To give you a bit of <code>Background()</code>:</p>
			<p class="quote">At Google, we developed a context package that makes it easy to pass request-scoped values, cancelation signals, and deadlines across API boundaries to all the goroutines involved in handling a request.</p>
			<p class="caption"><a href="https://blog.golang.org/context">https://blog.golang.org/context</a></p>
			<p>As mentioned earlier, the request can be cancelled at any time, therefore we have to check for this in several different places. Initially, I did this in the request handler, but after some more testing I realised the request could have made its way to the read channel. In that case, we also have to check for any cancellation while getting data from the data store.</p>
			<p>I am still unsure if this is the <em>best</em> approach, but I have manually and unit tested several scenarios and I am pretty confident with this solution. Some basic pseudo code is as follows:</p>
<pre class="go lines">
<code><span class="r">package</span> main</code>
<code></code>
<code><span class="r">import</span> (</code>
<code>    <span class="y">"context"<span></code>
<code>    <span class="y">"net/http"</span></code>
<code>    <span class="y">"time"</span></code>
<code>)</code>
<code></code>
<code><span class="r">type</span> dataRequest <span class="r">struct</span> {</code>
<code>    data chan string</code>
<code>    ctx  context.Context</code>
<code>}</code>
<code></code>
<code><span class="r">func</span> <span class="g">handler</span>(reqStream chan dataRequest) http.HandlerFunc {</code>
<code>    <span class="r">return func</span>(w http.ResponseWriter, r <span class="r">*</span>http.Request) {</code>
<code>        ctx, cancel <span class="r">:=</span> context.WithTimeout(r.Context(), 5<span class="r">*</span>time.Second)</code>
<code>        <span class="r">defer</span> cancel()</code>
<code></code>
<code>        req <span class="r">:=</span> dataRequest{</code>
<code>            data: make(chan string, 1),</code>
<code>            ctx:  ctx,</code>
<code>        }</code>
<code></code>
<code>        <span class="r">select</span> {</code>
<code>        case reqStream <span class="r"><-</span> req:</code>
<code>            <span class="c">// request pushed to que</span></code>
<code>        case <span class="r"><-</span>ctx.Done():</code>
<code>            <span class="c">// don't push onto reqStream if ctx done</span></code>
<code>        }</code>
<code></code>
<code>        <span class="r">select</span> {</code>
<code>        case <span class="r"><-</span>ctx.Done():</code>
<code>            <span class="c">// don't try and serve content if ctx done</span></code>
<code>        case data <span class="r">:= <-</span>req.data:</code>
<code>            <span class="c">// return data to client</span></code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code><span class="r">func</span> <span class="g">main</span>() {</code>
<code>    dataReqs <span class="r">:=</span> make(chan dataRequest)</code>
<code>    <span class="r">go func</span>() {</code>
<code>        <span class="r">for</span> {</code>
<code>            <span class="r">select</span> {</code>
<code>            case req <span class="r">:= <-</span>dataReqs:</code>
<code>                <span class="r">select</span> {</code>
<code>                case <span class="r"><-</span>req.ctx.Done():</code>
<code>                    <span class="c">// don't push onto data channel if ctx done</span></code>
<code>                case req.data <span class="r"><-</span> <span class="y">"some data"</span>:</code>
<code>                    <span class="c">// get data from store</span></code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>    }()</code>
<code>    http.HandleFunc(<span class="y">"/"</span>, handler(dataReqs))</code>
<code>    http.ListenAndServe(<span class="y">":8080"</span>, nil)</code>
<code>}</code>
</pre>
<h3>Resources</h3>
<ul>
    <li><a href="https://blog.golang.org/context">Go Concurrency Patterns: Context</a></li>
</ul>
</div>
	
	<footer>
		<p><a href="/etc">[et-see]</a></p>
		<p><a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></p>
	</footer>
</body>
</html>