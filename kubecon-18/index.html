<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="description" content="A collection of articles focused around distributed systems, networking, instrumentation and related topics.">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>KubeCon &amp; CloudNativeCon — North America ‘18</title>
	<link rel="stylesheet" href="../site.css" />
	<link rel="icon" type="image/png" href="/images/favicon.png" />
</head>
<body>
	<div class="sidebar">
		<h1><a href="/">Programming, thoughts and paradigms</a></h1>
		<h2>A collection of articles focused around distributed systems, networking, instrumentation and related topics.</h2>
		<ul>
			<li>GitHub <a href="https://github.com/syscll">syscll</a></li>
			<li>Twitter <a href="https://twitter.com/syscll">@syscll</a></li>
			<li>PGP <a href="https://keybase.io/syscll">0B90 148B BFCF C519</a></li>
		</ul>
		<p>Subscribe to the <a href="../index.xml">RSS feed</a>.</p>
		<p>All content is licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)</a>.</p>
	</div>
	<div class="content">
		<div class="archive">
			<h2>KubeCon &amp; CloudNativeCon — North America ‘18</h2>
			<p class="date">Dec 30, 2018</p>
			<img src="../images/kubecon-18.jpg" title="KubeCon &amp; CloudNativeCon — North America ‘18" />
			<p>With a grand total of 8000 attendees, 150+ speakers, 250+ talks, 100+ sponsors and more swag than I've ever seen at a conference, this was an event not to be missed.</p>
			<p>It took me a good few hours to read through the schedule and decide which talks I wanted to attend, but luckily I had a lot of time to pass on the 10-hour flight from London. However, this turned out to be an extremely difficult task as there were a lot of overlapping talks I was interested in. This led to me having to make some sacrifices, but thankfully the majority of talks were recorded.</p>
			<p>I could spend hours talking about the experience as a whole, but I wanted to outline my top 3 take aways:</p>
			<h3>Battle of the Service Meshes</h3>
			<p class="quote">A service mesh is a dedicated infrastructure layer for making service-to-service communication safe, fast, and reliable.A service mesh is a dedicated infrastructure layer for making service-to-service communication safe, fast, and reliable.</p>
			<p class="caption"><a href="https://blog.buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one">https://blog.buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one</a></p>
			<p>I've been experimenting with service meshes, mainly <a href="https://linkerd.io/">Linkerd</a>, for around 12 months and they've proved to be a key tool in my infrastructure arsenal. One of the most useful features is the network proxy. By proxying all of your traffic through a service mesh, it becomes extremely easy to gather important metrics such as latency, success and failure rates, status codes, connection errors, etc. This can help when investigating network bottlenecks and calculating scaling metrics.</p>
			<p>One of the main talking points at the conference was <a href="https://www.envoyproxy.io/">Envoy Proxy</a>, a recently graduated <a href="https://www.cncf.io/projects/">CNCF project</a> developed by the folks at <a href="https://www.lyft.com/">Lyft</a>. I'd heard about Envoy before, but got the chance to see it up close and personal for the first time. It provides Advanced Load Balancing and Observability among several other features such as HTTP/2 and gRPC support.</p>
			<p>Constance Caramanolis from Lyft gave a great talk on <a href="https://youtu.be/q_psmHeXaGI">Reducing Mean-Time-to-Detection of Incidents with an Envoy Service Mesh</a>.</p>
			<h3>Autoscaling on Latency</h3>
			<p>A common practice in cloud computing, especially <a href="https://github.com/kubernetes/autoscaler">Kubernetes</a>, is autoscaling services based on important metrics such as CPU and memory utilisation. This is the standard behaviour for most scaling applications, but it's not always the most reliable.</p>
			<p>Latency is one of the most important metrics you should be collecting - if you're not already! Database lookups, data processing, DNS queries, queue backups, etc. can all have a significant effect on request and response timings. Your service might have a small footprint, however, it could severely underperform due to latency throughout the network.</p>
			<p>Thomas Rampelberg from <a href="https://buoyant.io/">Bouyant</a> spoke in detail about how to <a href="https://youtu.be/gSiGFH4ZnS8">Scale Your Service on What Matters: Autoscaling on Latency</a>.</p>
			<h3>Instrument everything</h3>
			<p>Instrumenting services isn't a new concept, but there are a lot of great open-source metrics platforms embracing Kubernetes and dedicating work to provide detailed deployment methods. <a href="https://github.com/influxdata/influxdb-operator">InfluxDB</a>, <a href="https://github.com/coreos/prometheus-operator">Prometheus</a> and <a href="https://github.com/grafana/kubernetes-app">Grafana</a> are just a handful of OSS that have recently released operators, documentation and apps that enable these services to be easily configured to run on Kubernetes.</p>
			<p>Instrumentation should be a first-class citizen for any service running in a standalone or distributed environment. Metrics are just as important as logs - if not more. Using them together can help diagnose problems exponentially, especially when tracing distributed systems or monitoring usage.</p>
			<p>Rob Szumski &amp; Chance Zibolski from Red Hat gave a demo on <a href="https://youtu.be/JHmWRBWPKog">Collecting Operational Metrics for a Cluster with 5,000 Namespaces</a>.</p>
		</div>
	</div>
</body>
</html>
